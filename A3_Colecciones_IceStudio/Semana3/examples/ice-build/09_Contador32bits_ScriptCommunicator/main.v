// Code generated by Icestudio 0.7.1w202109100309

`default_nettype none

//---- Top entity
module main #(
 parameter v384ddf = 1
) (
 input vf0b97b,
 input vclk,
 output vaad62c,
 output [0:7] vinit
);
 localparam p0 = v384ddf;
 wire [0:31] w1;
 wire w2;
 wire w3;
 wire w4;
 wire w5;
 wire w6;
 wire w7;
 wire w8;
 assign vaad62c = w2;
 assign w4 = vf0b97b;
 assign w6 = vclk;
 assign w7 = vclk;
 assign w8 = vclk;
 assign w5 = w3;
 assign w7 = w6;
 assign w8 = w6;
 assign w8 = w7;
 va9a5bc #(
  .vfb06ae(p0)
 ) v9649dc (
  .v2a8434(w3),
  .vac0eb2(w6)
 );
 v5bf32c va59abd (
  .vb7970b(w1),
  .ve61673(w4),
  .v7c533e(w5),
  .vdd729a(w7)
 );
 vf6f2c9 v26fe90 (
  .ve93dd7(w1),
  .vec02cd(w2),
  .v3a7630(w3),
  .vcdf509(w8)
 );
 assign vinit = 8'b00000000;
endmodule

/*-------------------------------------------------*/
/*--   */
/*-- - - - - - - - - - - - - - - - - - - - - - - --*/
/*-- 
/*-------------------------------------------------*/
//---- Top entity
module va9a5bc #(
 parameter vfb06ae = 1
) (
 input vac0eb2,
 output v2a8434
);
 localparam p2 = vfb06ae;
 wire w0;
 wire w1;
 assign v2a8434 = w0;
 assign w1 = vac0eb2;
 va9a5bc_v6cac2f #(
  .SEC(p2)
 ) v6cac2f (
  .o(w0),
  .clk(w1)
 );
endmodule

/*-------------------------------------------------*/
/*-- Corazon-tic-Sec  */
/*-- - - - - - - - - - - - - - - - - - - - - - - --*/
/*-- Corazón de bombeo de tics a con periodo paramétrico de segundos
/*-------------------------------------------------*/

module va9a5bc_v6cac2f #(
 parameter SEC = 0
) (
 input clk,
 output o
);
 //localparam SEC;
 
 //-- Constante para dividir y obtener una frecuencia de 1Hz
 localparam M = 12000000*SEC;
 
 //-- Calcular el numero de bits para almacenar M
 localparam N = $clog2(M);
 
 //-- Cable de reset para el contador
 wire reset;
 
 //-- Registro del divisor
 reg [N-1:0] divcounter;
 
 
 //-- Contador con reset
 always @(posedge clk)
   if (reset)
     divcounter <= 0;
   else
     divcounter <= divcounter + 1;
 
 //-- Comparador que resetea el contador cuando se alcanza el tope
 assign reset = (divcounter == M-1);
 
 //-- La salida es la señal de overflow
 assign o = reset;
 
 
 
 
endmodule
//---- Top entity
module v5bf32c #(
 parameter v5e4a03 = 33'h10000_0000
) (
 input vdd729a,
 input ve61673,
 input v7c533e,
 output [31:0] vb7970b,
 output v712cd1
);
 localparam p1 = v5e4a03;
 wire w0;
 wire w2;
 wire w3;
 wire w4;
 wire [0:31] w5;
 assign w0 = ve61673;
 assign w2 = v7c533e;
 assign w3 = vdd729a;
 assign v712cd1 = w4;
 assign vb7970b = w5;
 v5bf32c_vbd6086 #(
  .M(p1)
 ) vbd6086 (
  .rst(w0),
  .cnt(w2),
  .clk(w3),
  .ov(w4),
  .q(w5)
 );
endmodule

/*-------------------------------------------------*/
/*-- 32-bits-counter-rst  */
/*-- - - - - - - - - - - - - - - - - - - - - - - --*/
/*-- 32-bits M module up counter, with reset 
/*-------------------------------------------------*/

module v5bf32c_vbd6086 #(
 parameter M = 0
) (
 input clk,
 input rst,
 input cnt,
 output [31:0] q,
 output ov
);
 //-- Numero de bits del contador
 localparam N = 32; 
 
 //-- En contadores de N bits:
 //-- M = 2 ** N
 
 //-- Internamente usamos un bit mas
 //-- (N+1) bits
 reg [N:0] qi = 0;
 
 always @(posedge clk)
   if (rst | ov)
     qi <= 0;
   else
     if (cnt)
       qi <= qi + 1;
       
 assign q = qi;
 
 //-- Comprobar overflow
 assign ov = (qi == M);
     
endmodule
//---- Top entity
module vf6f2c9 #(
 parameter vab8753 = 115200
) (
 input [31:0] ve93dd7,
 input v3a7630,
 input vcdf509,
 output vec02cd
);
 localparam p1 = vab8753;
 wire [0:7] w0;
 wire [0:1] w2;
 wire w3;
 wire w4;
 wire w5;
 wire w6;
 wire w7;
 wire [0:1] w8;
 wire w9;
 wire w10;
 wire w11;
 wire w12;
 wire w13;
 wire w14;
 wire [0:7] w15;
 wire [0:7] w16;
 wire [0:7] w17;
 wire [0:7] w18;
 wire [0:31] w19;
 wire w20;
 wire w21;
 wire w22;
 wire w23;
 wire w24;
 wire w25;
 assign vec02cd = w5;
 assign w13 = v3a7630;
 assign w14 = v3a7630;
 assign w19 = ve93dd7;
 assign w20 = vcdf509;
 assign w21 = vcdf509;
 assign w22 = vcdf509;
 assign w23 = vcdf509;
 assign w24 = vcdf509;
 assign w25 = vcdf509;
 assign w8 = w2;
 assign w9 = w3;
 assign w12 = w4;
 assign w14 = w13;
 assign w21 = w20;
 assign w22 = w20;
 assign w22 = w21;
 assign w23 = w20;
 assign w23 = w21;
 assign w23 = w22;
 assign w24 = w20;
 assign w24 = w21;
 assign w24 = w22;
 assign w24 = w23;
 assign w25 = w20;
 assign w25 = w21;
 assign w25 = w22;
 assign w25 = w23;
 assign w25 = w24;
 v33837d v452f7b (
  .vf3dbae(w0),
  .v7b814e(w2),
  .vfa3ec2(w15),
  .vf9974f(w16),
  .vf0c0b7(w17),
  .v55f4cc(w18)
 );
 vb959c2 ve3e153 (
  .v3c6908(w4),
  .vb4c770(w11),
  .ve68648(w13),
  .v581b48(w21)
 );
 vc6459c #(
  .ved2ada(p1)
 ) va2abe7 (
  .v19b8dd(w0),
  .v01321e(w3),
  .v8caaa5(w5),
  .v05e99b(w6),
  .ve9a78f(w20)
 );
 vd6bbdd v05cb68 (
  .vdbb75f(w6),
  .v08bfd6(w7),
  .v02d455(w24)
 );
 vf6f2c9_v9ebe9e v9ebe9e (
  .o(w7),
  .estado(w8),
  .done(w10),
  .inicio(w14),
  .clk(w23)
 );
 v1c7dae ve1951b (
  .vf54559(w9),
  .ve8318d(w10),
  .va4102a(w25)
 );
 vcc6e10 v7b62b6 (
  .vd76104(w2),
  .v7c533e(w3),
  .v712cd1(w4),
  .v26172c(w11),
  .ve61673(w12),
  .vdd729a(w22)
 );
 v60e849 v2d9495 (
  .v46163a(w15),
  .v37918a(w16),
  .v72947e(w17),
  .v3ec835(w18),
  .v88a8bc(w19)
 );
endmodule

/*-------------------------------------------------*/
/*-- Tx_32bits  */
/*-- - - - - - - - - - - - - - - - - - - - - - - --*/
/*-- Transmite 32 bits en Paralelo a serie por RS232 (entrada de 32 bits)
/*-------------------------------------------------*/

module vf6f2c9_v9ebe9e (
 input clk,
 input [1:0] estado,
 input inicio,
 input done,
 output o
);
 
 reg o=0;
 
 always @(posedge clk)
 case (estado)
   0:if(inicio) o=~o;
      else o=o;
   default: if(done) o=~o;
 endcase
endmodule
//---- Top entity
module v33837d (
 input [7:0] vfa3ec2,
 input [7:0] vf9974f,
 input [7:0] vf0c0b7,
 input [7:0] v55f4cc,
 input [1:0] v7b814e,
 output [7:0] vf3dbae
);
 wire [0:7] w0;
 wire [0:7] w1;
 wire [0:7] w2;
 wire [0:7] w3;
 wire [0:1] w4;
 wire [0:7] w5;
 assign vf3dbae = w0;
 assign w1 = vfa3ec2;
 assign w2 = vf9974f;
 assign w3 = vf0c0b7;
 assign w4 = v7b814e;
 assign w5 = v55f4cc;
 v33837d_v463e55 v463e55 (
  .o(w0),
  .a(w1),
  .b(w2),
  .c(w3),
  .sel(w4),
  .d(w5)
 );
endmodule

/*-------------------------------------------------*/
/*-- Mux4To1_8  */
/*-- - - - - - - - - - - - - - - - - - - - - - - --*/
/*-- Multiplexor de 4 entradas de 8bits a  una salida de 8bits
/*-------------------------------------------------*/

module v33837d_v463e55 (
 input [7:0] a,
 input [7:0] b,
 input [7:0] c,
 input [7:0] d,
 input [1:0] sel,
 output [7:0] o
);
 //-- Multiplexor de 3 a 1, 
 //-- de 8 bits
 
 reg [7:0] _o= 8'b0000_0000;
 
 always @(*) begin
     case(sel)
         0: _o = a;
         1: _o = b;
         2: _o = c;
         3: _o = d;
         default: _o = 8'b0000_0000;
     endcase
 end
 
 assign o = _o;
 
endmodule
//---- Top entity
module vb959c2 #(
 parameter v679341 = 0
) (
 input v581b48,
 input ve68648,
 input v3c6908,
 output vb4c770
);
 localparam p4 = v679341;
 wire w0;
 wire w1;
 wire w2;
 wire w3;
 assign w0 = v581b48;
 assign w1 = ve68648;
 assign w2 = v3c6908;
 assign vb4c770 = w3;
 vb959c2_v4e11b3 #(
  .INI(p4)
 ) v4e11b3 (
  .clk(w0),
  .set(w1),
  .rst(w2),
  .q(w3)
 );
endmodule

/*-------------------------------------------------*/
/*-- Biestable-Set-Reset  */
/*-- - - - - - - - - - - - - - - - - - - - - - - --*/
/*-- Biestable con entradas de Set y Reset síncronas, para poner y quitar notaficaciones de eventos
/*-------------------------------------------------*/

module vb959c2_v4e11b3 #(
 parameter INI = 0
) (
 input clk,
 input set,
 input rst,
 output q
);
 reg q = INI;
 
 always @(posedge clk)
   if (set)
     q <= 1'b1;
   else if (rst)
     q<=1'b0;
endmodule
//---- Top entity
module vc6459c #(
 parameter ved2ada = 115200
) (
 input ve9a78f,
 input [7:0] v19b8dd,
 input v05e99b,
 output v8caaa5,
 output v2da441,
 output v01321e
);
 localparam p1 = ved2ada;
 wire w0;
 wire w2;
 wire [0:7] w3;
 wire w4;
 wire w5;
 wire w6;
 assign v8caaa5 = w0;
 assign w2 = ve9a78f;
 assign w3 = v19b8dd;
 assign w4 = v05e99b;
 assign v2da441 = w5;
 assign v01321e = w6;
 vc6459c_vedebcc #(
  .BAUD(p1)
 ) vedebcc (
  .TX(w0),
  .clk(w2),
  .data(w3),
  .txmit(w4),
  .busy(w5),
  .done(w6)
 );
endmodule

/*-------------------------------------------------*/
/*-- Serial-tx  */
/*-- - - - - - - - - - - - - - - - - - - - - - - --*/
/*-- Transmisor serie
/*-------------------------------------------------*/

module vc6459c_vedebcc #(
 parameter BAUD = 0
) (
 input clk,
 input [7:0] data,
 input txmit,
 output TX,
 output busy,
 output done
);
 //-- Constantes para obtener las velocidades estándares
 `define B115200 104 
 `define B57600  208
 `define B38400  313
 `define B19200  625
 `define B9600   1250
 `define B4800   2500
 `define B2400   5000
 `define B1200   10000
 `define B600    20000
 `define B300    40000
 
 //-- Constante para calcular los baudios
 localparam BAUDRATE = (BAUD==115200) ? `B115200 : //-- OK
                       (BAUD==57600)  ? `B57600  : //-- OK
                       (BAUD==38400)  ? `B38400  : //-- Ok
                       (BAUD==19200)  ? `B19200  : //-- OK
                       (BAUD==9600)   ? `B9600   : //-- OK
                       (BAUD==4800)   ? `B4800   : //-- OK 
                       (BAUD==2400)   ? `B2400   : //-- OK
                       (BAUD==1200)   ? `B1200   : //-- OK
                       (BAUD==600)    ? `B600    : //-- OK
                       (BAUD==300)    ? `B300    : //-- OK
                       `B115200 ;  //-- Por defecto 115200 baudios
 
 
 //---- GENERADOR DE BAUDIOS
 
 //-- Calcular el numero dde bits para almacenar el divisor
 localparam N = $clog2(BAUDRATE);
 
 //-- Contador para implementar el divisor
 //-- Es un contador modulo BAUDRATE
 reg [N-1:0] divcounter = 0;
 
 //-- Cable de reset para el contador
 //-- Comparador que resetea el contador cuando se alcanza el tope
 //-- o cuando el estado del biestable es 0 (apagado)
 wire reset = ov_gen | (state == 0);
 
 //-- Contador con reset
 always @(posedge clk)
   if (reset)
     divcounter <= 0;
   else
     divcounter <= divcounter + 1;
 
 //-- Hemos llegado al final
 wire ov_gen = (divcounter == BAUDRATE-1);
 
 
 
 //-- REGISTRO DESPLAZAMIENTO
 
 //-- Salida serie. Inicialmete a 1 (reposo) 
 reg TX = 1;
 
 //-- Registro de desplazamiento de 9 bits
 //-- Inicializado todo a 1s
 reg [8:0] q = 9'h1FF;
 
 //-- La entrada de shift es la salida del generador de baudios
 wire shift = ov_gen;
 
 always @(posedge clk)
   if (txmit_tic)
   //-- Carga del registro
     q <= {data, 1'b0};
     
   else if (shift)
     //-- Desplazamiento. Rellenar con 1 (bit de stop)
     q <= {1'b1, q[8:1]};
     
 //-- Sacar el bit de menor peso por serial-out    
 wire so;
 assign so = q[0];
 
 //-- La salida tx la registramos
 always @(posedge clk)
   TX <= so;
   
 //-- La señal de entrada txmit se pasa por un 
 //-- detector de flancos de subida para generar un tic
 reg q_re = 0;
 wire txmit_tic;
 
 always @(posedge clk)
   q_re <= txmit;
   
 assign txmit_tic = (~q_re & txmit);  
 
 
 
 //-- Estado de transmisor
 //-- 0: Parado
 //-- 1: Ocupado (transmitiendo)
 reg state = 0;
   
 always @(posedge clk)
   //-- Empieza la transmision: ocupado
   if (txmit)
     state <= 1'b1;
     
   //-- Acaba la transmision: libre    
   else if (ov)
     state <= 1'b0;
 
 //-- Contador de bits enviados
 reg [3:0] bits = 0;
 always @(posedge clk)
   //-- Si la cuenta ha terminado... volver a 0
   if (ov)
     bits <= 2'b00;
   else
     if (shift)
       bits <= bits + 1;
 
 //-- Comprobar si se ha transmitido el último bit (overflow)
 //-- 1 bit de start + 8 bits de datos + 1 bit de stop
 wire ov = (bits == 10);
 
 //-- La señal de ocupado es el estado del transmisor
 assign busy = state;
 
 //-- La señal de done es la de overflow pero retrasada un
 //-- periodo de reloj del sistema y que el biestable 
 //-- llegue al estado de parado antes de que se 
 //-- empiece otra transmision
 
 reg done=0;
 
 always @(posedge clk)
   done <= ov;
 
endmodule
//---- Top entity
module vd6bbdd (
 input v08bfd6,
 input v02d455,
 output vdbb75f
);
 wire w0;
 wire w1;
 wire w2;
 assign vdbb75f = w0;
 assign w1 = v08bfd6;
 assign w2 = v02d455;
 vd6bbdd_v3523b6 v3523b6 (
  .Toggle(w0),
  .in(w1),
  .clk(w2)
 );
endmodule

/*-------------------------------------------------*/
/*-- Tic  */
/*-- - - - - - - - - - - - - - - - - - - - - - - --*/
/*-- Detectar si señal ha sufrido cambio y si ha sido flanco de subida o bajada-Modo1
/*-------------------------------------------------*/

module vd6bbdd_v3523b6 (
 input in,
 input clk,
 output Toggle
);
 
 reg Q=0;
 
 //Biestable D donde capturo estado actual (in) y anterior (Q)
 always @(posedge clk)
  Q<=in;
 
 //Con datos del estado actual ya anterior, realizando un circutio combinacional
 //puedo saber si la señal a cambiado y si ha subido o ha bajado el flanco.
 
 assign Toggle= (Q ^ in); //Si son distintos es que hay un cambio
 
endmodule
//---- Top entity
module v1c7dae #(
 parameter v71e305 = 0
) (
 input va4102a,
 input vf54559,
 output ve8318d
);
 localparam p2 = v71e305;
 wire w0;
 wire w1;
 wire w3;
 assign w0 = va4102a;
 assign ve8318d = w1;
 assign w3 = vf54559;
 v1c7dae_vb8adf8 #(
  .INI(p2)
 ) vb8adf8 (
  .clk(w0),
  .q(w1),
  .d(w3)
 );
endmodule

/*-------------------------------------------------*/
/*-- Biestable-D  */
/*-- - - - - - - - - - - - - - - - - - - - - - - --*/
/*-- Biestable de datos (Tipo D). Cuando se recibe un tic por load se captura el dato
/*-------------------------------------------------*/

module v1c7dae_vb8adf8 #(
 parameter INI = 0
) (
 input clk,
 input d,
 output q
);
 reg q = INI;
 always @(posedge clk)
   q <= d;
endmodule
//---- Top entity
module vcc6e10 #(
 parameter v5e4a03 = 4
) (
 input vdd729a,
 input ve61673,
 input v26172c,
 input v7c533e,
 output [1:0] vd76104,
 output v712cd1
);
 localparam p2 = v5e4a03;
 wire [0:1] w0;
 wire w1;
 wire w3;
 wire w4;
 wire w5;
 wire w6;
 assign vd76104 = w0;
 assign w1 = ve61673;
 assign w3 = v7c533e;
 assign w4 = vdd729a;
 assign v712cd1 = w5;
 assign w6 = v26172c;
 vcc6e10_vbd6086 #(
  .M(p2)
 ) vbd6086 (
  .q(w0),
  .rst(w1),
  .cnt(w3),
  .clk(w4),
  .ov(w5),
  .en(w6)
 );
endmodule

/*-------------------------------------------------*/
/*-- Contador-2bits-up-rst-en  */
/*-- - - - - - - - - - - - - - - - - - - - - - - --*/
/*-- Contador módulo M, ascendente, de 2 bits, con reset 
/*-------------------------------------------------*/

module vcc6e10_vbd6086 #(
 parameter M = 0
) (
 input clk,
 input rst,
 input en,
 input cnt,
 output [1:0] q,
 output ov
);
 //-- Numero de bits del contador
 localparam N = 2; 
 
 //-- En contadores de N bits:
 //-- M = 2 ** N
 
 //-- Internamente usamos un bit mas
 //-- (N+1) bits
 reg [N:0] qi = 0;
 
 always @(posedge clk)
   if (rst || ov)
     qi <= 2'b00;
   else
     if (cnt && en)
       qi <= qi + 1;
       
 assign q = qi;
 
 //-- Comprobar overflow
 assign ov = (qi == M);
     
endmodule
//---- Top entity
module v60e849 (
 input [31:0] v88a8bc,
 output [7:0] v46163a,
 output [7:0] v37918a,
 output [7:0] v72947e,
 output [7:0] v3ec835
);
 wire [0:7] w0;
 wire [0:7] w1;
 wire [0:7] w2;
 wire [0:7] w3;
 wire [0:31] w4;
 assign v46163a = w0;
 assign v37918a = w1;
 assign v72947e = w2;
 assign v3ec835 = w3;
 assign w4 = v88a8bc;
 v60e849_v071a0a v071a0a (
  .H2(w0),
  .H1(w1),
  .L2(w2),
  .L1(w3),
  .in(w4)
 );
endmodule

/*-------------------------------------------------*/
/*-- Split 32  4 x 8  */
/*-- - - - - - - - - - - - - - - - - - - - - - - --*/
/*-- Split bus 32 bits to 4 x 8 bits
/*-------------------------------------------------*/

module v60e849_v071a0a (
 input [31:0] in,
 output [7:0] H2,
 output [7:0] H1,
 output [7:0] L2,
 output [7:0] L1
);
 
 //Split Bus 32 bits in 4 x 8 bits
 
 assign H2=in[31:24];
 assign H1=in[23:16];
 assign L2=in[15:8];
 assign L1=in[7:0];
 
endmodule
