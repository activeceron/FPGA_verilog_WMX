// Code generated by Icestudio 0.7.1w202109100309

`default_nettype none

//---- Top entity
module main (
 input v184283,
 output [1:0] v5e6633,
 output [0:5] vinit
);
 wire [0:1] w0;
 wire [0:1] w1;
 wire w2;
 wire w3;
 wire w4;
 wire w5;
 wire w6;
 assign v5e6633 = w0;
 assign w3 = v184283;
 assign w5 = v184283;
 assign w6 = v184283;
 assign w4 = w2;
 assign w5 = w3;
 assign w6 = w3;
 assign w6 = w5;
 ve79148 v36548a (
  .vd76104(w1),
  .v7c533e(w2),
  .vdd729a(w5)
 );
 va9a5bc vdec162 (
  .v2a8434(w2),
  .vac0eb2(w6)
 );
 main_vac0bf4 vac0bf4 (
  .q(w0),
  .in(w1),
  .clock(w3),
  .d(w4)
 );
 assign vinit = 6'b000000;
endmodule

/*-------------------------------------------------*/
/*--   */
/*-- - - - - - - - - - - - - - - - - - - - - - - --*/
/*-- 
/*-------------------------------------------------*/
//---- Top entity
module ve79148 #(
 parameter v5e4a03 = 4
) (
 input vdd729a,
 input ve61673,
 input v7c533e,
 output [1:0] vd76104,
 output v712cd1
);
 localparam p2 = v5e4a03;
 wire [0:1] w0;
 wire w1;
 wire w3;
 wire w4;
 wire w5;
 assign vd76104 = w0;
 assign w1 = ve61673;
 assign w3 = v7c533e;
 assign w4 = vdd729a;
 assign v712cd1 = w5;
 ve79148_vbd6086 #(
  .M(p2)
 ) vbd6086 (
  .q(w0),
  .rst(w1),
  .cnt(w3),
  .clk(w4),
  .ov(w5)
 );
endmodule

/*-------------------------------------------------*/
/*-- Contador-2bits-up-rst  */
/*-- - - - - - - - - - - - - - - - - - - - - - - --*/
/*-- Contador módulo M, ascendente, de 2 bits, con reset 
/*-------------------------------------------------*/

module ve79148_vbd6086 #(
 parameter M = 0
) (
 input clk,
 input rst,
 input cnt,
 output [1:0] q,
 output ov
);
 //-- Numero de bits del contador
 localparam N = 2; 
 
 //-- En contadores de N bits:
 //-- M = 2 ** N
 
 //-- Internamente usamos un bit mas
 //-- (N+1) bits
 reg [N:0] qi = 0;
 
 always @(posedge clk)
   if (rst | ov)
     qi <= 2'b00;
   else
     if (cnt)
       qi <= qi + 1;
       
 assign q = qi;
 
 //-- Comprobar overflow
 assign ov = (qi == M);
     
endmodule
//---- Top entity
module va9a5bc #(
 parameter vfb06ae = 1
) (
 input vac0eb2,
 output v2a8434
);
 localparam p2 = vfb06ae;
 wire w0;
 wire w1;
 assign v2a8434 = w0;
 assign w1 = vac0eb2;
 va9a5bc_v6cac2f #(
  .SEC(p2)
 ) v6cac2f (
  .o(w0),
  .clk(w1)
 );
endmodule

/*-------------------------------------------------*/
/*-- Corazon-tic-Sec  */
/*-- - - - - - - - - - - - - - - - - - - - - - - --*/
/*-- Corazón de bombeo de tics a con periodo paramétrico de segundos
/*-------------------------------------------------*/

module va9a5bc_v6cac2f #(
 parameter SEC = 0
) (
 input clk,
 output o
);
 //localparam SEC;
 
 //-- Constante para dividir y obtener una frecuencia de 1Hz
 localparam M = 12000000*SEC;
 
 //-- Calcular el numero de bits para almacenar M
 localparam N = $clog2(M);
 
 //-- Cable de reset para el contador
 wire reset;
 
 //-- Registro del divisor
 reg [N-1:0] divcounter;
 
 
 //-- Contador con reset
 always @(posedge clk)
   if (reset)
     divcounter <= 0;
   else
     divcounter <= divcounter + 1;
 
 //-- Comparador que resetea el contador cuando se alcanza el tope
 assign reset = (divcounter == M-1);
 
 //-- La salida es la señal de overflow
 assign o = reset;
 
 
 
 
endmodule

module main_vac0bf4 (
 input [1:0] in,
 input d,
 input clock,
 output [1:0] q
);
 // parameter --> definir costantes
 //module param (input [1:0] in,output [1:0]q);
 
 parameter cero=2'b00, uno=2'b01, dos=2'b10, 
           tres =2'b11;
           
 reg [1:0] dato=0;  //tipo reg 
 
 
 //************************** Multiplexor*******
 always @(*)
   case(in)
     0:dato=cero;
     1:dato=uno;
     2:dato=dos;
     3:dato=tres;
   endcase
 
 //assign q=dato;  // q tipo wire
 
 //**************************** Biestable ********
 reg [1:0] q=0;
 
 always @(posedge clock)
  if(d)
    q<=dato;
  else q<=q;
 
 
endmodule
